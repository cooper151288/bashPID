#!/bin/bash
#A PID fan controller
#Depenencies: bash, GNU bc
#Matt Cooper, 2015
# TODO: config file, generic sensor/cdev
# -The initialisation part looks like it would
#  be better off in a .conf
#
# - ACPI and cpufreq throttling look like they
#   can be implemented here in the same fashion
#
# - Would precision timing be better? Code
#   assumes that calculation time is negligible,
#   could use date time to give system time in ns
#   and put that as dt in calcs
#
#DESIRED: online tuning and autotune
################initialisation:

source config
######################################################################
echo 1 > $pwm1en &           #enable pwm
echo 1 > $pwm2en &           #enable pwm
wait

#echo 255 > $pwm1path &                             #set initial pwm here
#echo 255 > $pwm2path &                             #set initial pwm here
#sleep 5                                            #use if you want a running start
pwm_old1=$(cat $pwm1path)                           #setup pwm_old
pwm_old2=$(cat $pwm2path)                           #setup pwm_old
pwm_raw1=$pwm_old1                                  #setup raw pwm
pwm_raw2=$pwm_old2
##set up old temps - only needed for weighted average derivative
T5=$(cat $temp1)
#E5=$(($T5 - $s1))
#sleep $dt
T4=$(cat $temp1)
#E4=$(($T4 - $s1))
#sleep $dt
T3=$(cat $temp1)
#E3=$(($T3 - $s1))
#sleep $dt
T2=$(cat $temp1)
#E2=$(($T2 - $s1))
#sleep $dt
T1=$(cat $temp1)
#E1=$(($T1 - $s1))
#sleep $dt
T0=$(cat $temp1)
#E0=$(($T0 - $s1))

O1=$C1=$C2
I1=$I1init
I2=$I2init
##begin main loop

while [ $T0 -lt $Tmax ] #break loop when T>Tmax
       do time {
          T5=$T4
          T4=$T3
          T3=$T2
          T2=$T1
          T1=$T0

#########
sleep $dt
#########
       T0=$(cat $temp1)
##temp functions now stored
##################################console output for user
clear
date
echo s1 = $s1 s2 = $s2
echo pwm1 $(cat $pwm1path)
echo pwm2 $(cat $pwm2path)
echo Fan Speed = $(cat $SuperIo/fan1_input)
echo pwm_raw1 = $pwm_raw1 pwm_raw2 = $pwm_raw2
echo P1 = $P1, P2 = $P2, I1 = $I1, I2 = $I2, D1 = $D1, D2 = $D2
echo O1 = $O1 O2 = $O2
echo T5 = $T5 T4 = $T4 T3 = $T3 T2 = $T2 T1 = $T1 T0 = $T0
echo E5 = $E5 E4 = $E4 E3 = $E3 E2 = $E2 E1 = $E1 E0 = $E0
echo pwm_new1 = $pwm_new1 pwm_new2 = $pwm_new2
##################################################

### Function definition###
## parameters: p i d s maxtrip max mintrip min C
##
##
function PID
{ 
if [ $T0 -gt $5 ]
 then
 pwm_new1=$6
 pwm_raw1=$6
 elif [ $T0 -lt $7 ]
 then
 pwm_new1=$8
 pwm_raw1=$8
 else

{
          E5=$(($T5 - $4))
          E4=$(($T4 - $4))
          E3=$(($T3 - $4))
          E2=$(($T2 - $4))
          E1=$(($T1 - $4))
          E0=$(($T0 - $4))
#Integral - trapezium rule with min/max values
I1=$(echo "(($2 * $dt * $half * ($E0 + $E1)) + $I1 )" | bc -l)
I1int=$(echo "($I1 + 0.5)/1" | bc)               #now an integer
if [ $I1int -gt $I1max ]
  then
  I1=$I1max
  elif [ $I1int -lt $I1min ]
  then
  I1=$I1min
  else
  :
fi

#(derivative- use simple definition)
#D= d * (err_last - err_now) / dt
#simple derivative
#D1=$(echo "$3 *  $(($E0 - $E1)) / $dt" | bc -l)
#weighted average
D=$(echo "$3 *  (($(($E0 - $E1)) / $dt) + $(($E0 - $E2)) / (4 * $dt) + $(($E0 - $E3)) / (6 * $dt) + $(($E0 - $E4)) / (8 * $dt) + $(($E0 - $E5)) / (10 * $dt))" | bc -l)
# Proportional term
P=$(echo "$1 * $E0" | bc -l)
O1=$(echo "$P1 + $I1 + $D1" | bc -l)
pwm_raw1=$(echo "$C1 + $O1" | bc -l) # add the constants in
pwm_new1=$(echo "($pwm_raw1 + 0.5)/1" | bc) #now an integer
if [ $pwm_new1 -gt $5 ]
 then
 pwm_new1=$6
 pwm_raw1=$6
 elif [ $pwm_new1 -lt $7 ]
 then
 pwm_new1=$8
 pwm_raw1=$8
 else
:
fi
pwm_old1=$(echo "($pwm_raw1 + $O1 + 0.5)/1" | bc) #need to call from these raw values
 }
fi
echo $pwm_new1 > $pwm1path &          #these lines do the fanspeed
 }
#########end of function################

###########PID part-do for both sets of constants
###################pwm1######################
if [ $T0 -gt $pwm1_maxtrip ]
 then
 pwm_new1=$pwm_max1_1
 pwm_raw1=$pwm_max1_1
 elif [ $T0 -lt $pwm1_mintrip ]
 then
 pwm_new1=$pwm_min1_1
 pwm_raw1=$pwm_min1_1
 else

{
          E5=$(($T5 - $s1))
          E4=$(($T4 - $s1))
          E3=$(($T3 - $s1))
          E2=$(($T2 - $s1))
          E1=$(($T1 - $s1))
          E0=$(($T0 - $s1))
#Integral - trapezium rule with min/max values
I1=$(echo "(($i1 * $dt * $half * ($E0 + $E1)) + $I1 )" | bc -l)
I1int=$(echo "($I1 + 0.5)/1" | bc)               #now an integer
if [ $I1int -gt $I1max ]
  then
  I1=$I1max
  elif [ $I1int -lt $I1min ]
  then
  I1=$I1min
  else
  :
fi

#(derivative- use simple definition)
#D= d * (err_last - err_now) / dt
#simple derivative
#D1=$(echo "$d1 *  $(($E0 - $E1)) / $dt" | bc -l)
#weighted average
D1=$(echo "$d1 *  (($(($E0 - $E1)) / $dt) + $(($E0 - $E2)) / (4 * $dt) + $(($E0 - $E3)) / (6 * $dt) + $(($E0 - $E4)) / (8 * $dt) + $(($E0 - $E5)) / (10 * $dt))" | bc -l)
# Proportional term
P1=$(echo "$p1 * $E0" | bc -l)
O1=$(echo "$P1 + $I1 + $D1" | bc -l)
pwm_raw1=$(echo "$C1 + $O1" | bc -l) # add the constants in
pwm_new1=$(echo "($pwm_raw1 + 0.5)/1" | bc) #now an integer
if [ $pwm_new1 -gt $pwm_max1_1 ]
 then
 pwm_new1=$pwm_max1_1
 pwm_raw1=$pwm_max1_1
 elif [ $pwm_new1 -lt $pwm_min1_1 ]
 then
 pwm_new1=$pwm_min1_1
 pwm_raw1=$pwm_min1_1
 else
:
fi
pwm_old1=$(echo "($pwm_raw1 + $O1 + 0.5)/1" | bc) #need to call from these raw values
 }
fi
echo $pwm_new1 > $pwm1path &          #these lines do the fanspeed

###end of function###


########################end of pwm1################
