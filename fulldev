#!/bin/bash
################initialisation:

##global values##

dtsave=1        # Time base
dt=$dtsave
t=1             #time for overtemperature loop
half=0.5
Tmax=30000        #Max temperature, disable pwms (or whatever to get full fanspeed/cooling), sleep
Tmaxhyst=20000    #Hysteresis value for Tmax. Script starts from beginning once reached
SuperIo=/sys/devices/platform/it87.552           #store SuperIo path to make it easier to read and write for devices
fan=$SuperIo/fan1_input
temp1=/sys/devices/pci0000:00/0000:00:18.3/hwmon/hwmon*/temp1_input
coolsleep=1 #additional time to wait when tmaxhyst reached

###cooling device 1
p1=0.025            #Proportional gain
i1=0.0025           #Integral gain
d1=0.0000025        #derivative gain
pwm_max1=255 #used when the main loop is broken. leave at maximum
pwm1path=$SuperIo/pwm1
pwm1en=$SuperIo/pwm1_enable
C1=0   # controller bias values (Integration constants)
I1max=255    # Max value of integrator 1
I1min=110    # Min value of integrator 1
I1init=110    # initial value of integrator 1

##trip 1 for cdev 1
s1=25000            #set point
pwm1_mintrip=22500
pwm_min1_1=120            #pwm when below pwm1_mintrip
pwm1_maxtrip=27500
pwm_max1_1=255            #pwm when over this point

#cooling device 2
p2=0.025
i2=0.0025
d2=0.0000025
pwm_max2=255
pwm2path=$SuperIo/pwm3
pwm2en=$SuperIo/pwm3_enable
C2=25
I2max=300    # Max value of integrator 2
I2min=-20   # Min value of integrator 2
I2init=100    # initial value of integator 2
##trip 1 for cdev 2

pwm2_mintrip=12500
pwm_min2_1=0
pwm2_maxtrip=17500
pwm_max2_1=255
s2=15000
#####cpufreq cooling

gov_restart=conservative
gov_throttle=powersave
f0=4000000 #frequency states
#t0=30000
f1=3600000
t1=30000   ## corresponding temperatures; t0 is unused
f2=3400000
t2=35000
f3=2800000
t3=40000
f4=2100000
t4=45000
f5=1400000
t5=50000
#core=$(($nproc - 1))
#!/bin/bash
#A PID fan controller
#Depenencies: bash, GNU bc
#Matt Cooper, 2015
# TODO: config file, generic sensor/cdev
#
# - Experimental cpufreq support!
#   
# - Would precision timing be better? Code
#   assumes that calculation time is negligible,
#   could use date time to give system time in ns
#   and put that as dt in calcs
#
#DESIRED: online tuning and autotune
################initialisation:
source config
#for z in {0..7}
#do cpufreq-set -c $z -g $gov_restart -u 4000000
done
echo 1 > $pwm1en &           #enable pwm
echo 1 > $pwm2en &           #enable pwm
wait

#echo 255 > $pwm1path &                             #set initial pwm here
#echo 255 > $pwm2path &                             #set initial pwm here
#sleep 5                                            #use if you want a running start
pwm_old1=$(cat $pwm1path)                           #setup pwm_old
pwm_old2=$(cat $pwm2path)                           #setup pwm_old
pwm_raw1=$pwm_old1                                  #setup raw pwm
pwm_raw2=$pwm_old2
##set up old temps - only needed for weighted average derivative
for a in {5..0}; 
  do export T$a=$(cat $temp1)
  done
#T5=$(cat $temp1)
#E5=$(($T5 - $s1))
#sleep $dt
#T4=$(cat $temp1)
#E4=$(($T4 - $s1))
#sleep $dt
#T3=$(cat $temp1)
#E3=$(($T3 - $s1))
#sleep $dt
#T2=$(cat $temp1)
#E2=$(($T2 - $s1))
#sleep $dt
#T1=$(cat $temp1)
#E1=$(($T1 - $s1))
#sleep $dt
#T0=$(cat $temp1)
#E0=$(($T0 - $s1))

O1=$C1
O2=$C2
I1=$I1init
I2=$I2init
##begin main loop

while [ $T0 -lt $Tmax ] #break loop when T>Tmax
       do time {
          T5=$T4
          T4=$T3
          T3=$T2
          T2=$T1
          T1=$T0
#date '+%S%N'
#########
sleep $dt
#########
clear
       T0=$(cat $temp1)
##temp functions now stored
##################################console output for user
date
echo s1 = $s1 s2 = $s2
echo pwm1 $(cat $pwm1path) pwm2 $(cat $pwm2path)
echo pwm_new1 = $pwm_new1 pwm_new2 = $pwm_new2
echo Fan Speed = $(cat $SuperIo/fan1_input)
#echo pwm_raw1 = $pwm_raw1 pwm_raw2 = $pwm_raw2
echo P1 = $P1, P2 = $P2, I1 = $I1, I2 = $I2, D1 = $D1, D2 = $D2
#echo O1 = $O1 O2 = $O2
#echo T5 = $T5 T4 = $T4 T3 = $T3 T2 = $T2 T1 = $T1 T0 = $T0
#echo E5 = $E5 E4 = $E4 E3 = $E3 E2 = $E2 E1 = $E1 E0 = $E0
echo T0 = $T0
##################################################
if [[ $T0 -lt $pwm1_mintrip ]  && [ T0 -lt $pwm2_mintrip ]
  then
pwm_new1=$pwm_min1_1
pwm_new2=$$pwm_min2_1
echo pwm_new1 > $pwm1path &
echo pwm_new2 > $pwm2path &
  continue
fi
###########PID part-do for both sets of constants
###################pwm1######################
if [ $T0 -gt $pwm1_maxtrip ]
 then
 pwm_new1=$pwm_max1_1
 pwm_raw1=$pwm_max1_1
 I1=$I1max
 elif [ $T0 -lt $pwm1_mintrip ]
 then
 pwm_new1=$pwm_min1_1
 pwm_raw1=$pwm_min1_1
 else

{
          E5=$(($T5 - $s1))
          E4=$(($T4 - $s1))
          E3=$(($T3 - $s1))
          E2=$(($T2 - $s1))
          E1=$(($T1 - $s1))
          E0=$(($T0 - $s1))
#Integral - trapezium rule with min/max values
I1=$(echo "(($i1 * $dt * $half * ($E0 + $E1)) + $I1 )" | bc -l)
I1int=$(echo "($I1 + 0.5)/1" | bc)               #now an integer
if [ $I1int -gt $I1max ]
  then
  I1=$I1max
  elif [ $I1int -lt $I1min ]
  then
  I1=$I1min
  else
  :
fi
echo $I1 > data/I1 &
#(derivative- use simple definition)
#D= d * (err_last - err_now) / dt
#simple derivative
#D1=$(echo "$d1 *  $(($E0 - $E1)) / $dt" | bc -l)
#weighted average
D1=$(echo "$d1 * (($(($E0 - $E1)) / $dt) + $(($E0 - $E2)) / (4 * $dt) + $(($E0 - $E3)) / (6 * $dt) + $(($E0 - $E4)) / (8 * $dt) + $(($E0 - $E5)) / (10 * $dt))" | bc -l)
# Proportional term
P1=$(echo "$p1 * $E0" | bc -l)
O1=$(echo "$P1 + $I1 + $D1" | bc -l)
pwm_raw1=$(echo "$C1 + $O1" | bc -l) # add the constants in
pwm_new1=$(echo "($pwm_raw1 + 0.5)/1" | bc) #now an integer
if [ $pwm_new1 -gt $pwm_max1_1 ]
 then
 pwm_new1=$pwm_max1_1
 pwm_raw1=$pwm_max1_1
 elif [ $pwm_new1 -lt $pwm_min1_1 ]
 then
 pwm_new1=$pwm_min1_1
 pwm_raw1=$pwm_min1_1
 else
:
fi
pwm_old1=$(echo "($pwm_raw1 + $O1 + 0.5)/1" | bc) #need to call from these raw values
 }
fi
echo $pwm_new1 > $pwm1path &          #these lines do the fanspeed
date '+%S%N'
########################end of pwm1################
##############################pwm2#################
if [ $T0 -gt $pwm2_maxtrip ]
 then
 pwm_new2=$pwm_max2_1
 pwm_raw2=$pwm_max2_1
 I2=$I2max
 elif [ $T0 -lt $pwm2_mintrip ]
 then
 pwm_new2=$pwm_min2_1
 pwm_raw2=$pwm_min2_1
 echo $pwm_new2 > $pwm2path &
 continue
 else

{
          E5=$(($T5 - $s2))
          E4=$(($T4 - $s2))
          E3=$(($T3 - $s2))
          E2=$(($T2 - $s2))
          E1=$(($T1 - $s2))
          E0=$(($T0 - $s2))
I2=$(echo "(($i2 * $dt * $half * ($E0 + $E1)) + $I2 )" | bc -l)
I2int=$(echo "($I2 + 0.5)/1" | bc)
if [ $I2int -gt $I2max ]
 then
 I2=$I2max
 elif [ $I2int -lt $I2min ]
 then
 I2=$I2min
 else
:
fi
echo $I2 > data/I2 &
#D2=$(echo "$d2 *  $(($E0 - $E1)) / $dt" | bc -l)
D2=$(echo "$d2 *  (($(($E0 - $E1)) / $dt) + $(($E0 - $E2)) / (4 * $dt) + $(($E0 - $E3)) / (6 * $dt) + $(($E0 - $E4)) / (8 * $dt) + $(($E0 - $E5)) / (10 * $dt))" | bc -l)
P2=$(echo "$p2 * $E0" | bc -l)
#output O=P+I+D
O2=$(echo "$P2 + $I2 + $D2" | bc -l)
pwm_raw2=$(echo "$C2 + $O2" | bc -l) #
pwm_new2=$(echo "($pwm_raw2 + 0.5)/1" | bc)
if [ $pwm_new2 -gt $pwm_max2_1 ]
 then
 pwm_new2=$pwm_max2_1
 pwm_raw2=$pwm_max2_1
 elif [ $pwm_new2 -lt $pwm_min2_1 ]
 then
 pwm_new2=$pwm_min2_1
 pwm_raw2=$pwm_min2_1
 else
:
fi
pwm_old2=$(echo "($pwm_raw2 + $O2 + 0.5)/1" | bc)
 }
fi
echo $pwm_new2 > $pwm2path &           #change. be careful.
date '+%S%N'
################################end of pwm2##################
#########frequency scaler#####
#    if [ $T0 -lt $Tmaxhyst ]
#    then
#    dt=$dtsave
#    else
#    { 
#    if [ $T0 -gt $t5 ]
#      then { 
#        for z in {0..7}
#          do cpufreq-set -c $z -u $f5 -g $gov_throttle
#        done
#         dt=0.05
#         } 
#         else
#         then
#         for a in {4..1}
#         do { 
#         if [$T0 -gt $(eval echo \$t$a)
#               then { 
#        for z in {0..7}
#          do cpufreq-set -c $z -u $(eval echo \$f$a)
#           done
#           }
#          fi
#           }
#          done
#           }
#    elif [ $T0 -lt $t1 ]
#      then { 
#      echo $f0
#        for z in {0..7}
#          do cpufreq-set -c $z -u $f0 -g $gov_restart
#           done
#            dt=$dtsave
#            continue
#            }
#    elif [ $T0 -ge $t4 ]
#      then { 
#      echo $f4
#        for z in {0..7}
#          do cpufreq-set -c $z -u $f4 -g $gov_restart
#           done
#           dt=0.1
#            }
#     elif [ $T0 -ge $t3 ]
#      then { 
#      echo $f3
#        for z in {0..7}
#          do cpufreq-set -c $z -u $f3 -g $gov_restart
#           done
#           dt=0.2
#            }
#    elif [ $T0 -ge $t2 ]
#      then { 
#      echo $f2
#        for z in {0..7}
#          do cpufreq-set -c $z -u $f2 -g $gov_restart
#           done
#            }
#            dt=0.3
#    elif [ $T0 -ge $t1 ]
#      then { 
#      echo $f1
#        for z in {0..7}
#          do cpufreq-set -c $z -u $f1 -g $gov_restart
#           done
#           dt=0.5
#            }
#        fi
#         }
#         fi
#############end of frequency scaler
 }
done

#loop broken for cooling and reinitialisation

echo Too hot, fans on max
#for z in {0..7}
#do cpufreq-set -c $z -g $gov_throttle
#done
echo $pwm_max1 > $pwm1path &
echo $pwm_max2 > $pwm2path &
echo 0 > $pwm1en
echo 0 > $pwm2en


until [ $T0 -lt $Tmaxhyst ]
  do :
  { 
  T0=$(cat $temp1)
  echo T0 = $T0
    if [ $T0 -ge $t5 ]
      then { 
      echo $f5
        for z in {0..7}
          do cpufreq-set -c $z -u $f5 -g $gov_throttle
        done
         t=0.05
          }
    elif [ $T0 -lt $t1 ]
      then { 
      echo $f0
        for z in {0..7}
          do cpufreq-set -c $z -u $f0 -g $gov_restart
          continue
           done
           t=0.5
            }
    elif [ $T0 -ge $t4 ]
      then { 
      echo $f4
        for z in {0..7}
          do cpufreq-set -c $z -u $f4 -g $gov_restart
           done
           t=0.1
            }
     elif [ $T0 -ge $t3 ]
      then { 
      echo $f3
        for z in {0..7}
          do cpufreq-set -c $z -u $f3 -g $gov_restart
           done
           t=0.2
            }
    elif [ $T0 -ge $t2 ]
      then { 
      echo $f2
        for z in {0..7}
          do cpufreq-set -c $z -u $f2 -g $gov_restart
           done
           t=0.3
            }
    elif [ $T0 -ge $t1 ]
      then { 
      echo $f1
        for z in {0..7}
          do cpufreq-set -c $z -u $f1 -g $gov_restart
           done
           t=0.4
            }
        fi
sleep $t
date '+%S.%N'
 }
done
sleep $coolsleep
exec $0 #start from the beginning when cool. the config will apply changes too.
#!/bin/bash
##################################################
dtsave=5
dt=$dtsave
freq_path=/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies
freq_available=$(cat $freq_path)
freq_list=($(echo $freq_available | tr " " "\n" | sort -nr)) #this is an array
cores=$(($(nproc) - 1))
numfreq=$(($(echo $freq_available | wc -w) -1))
Thot=20000
Tstep=2500
temp=/sys/devices/virtual/thermal/thermal_zone11/temp
###################################################
    T0=$(cat $temp)
while [ $T0 -le 50000 ]
  do T0=$(cat $temp)
     echo temp $T0
           if [ $T0 -le $Thot ]
           then
             j=0
             f=${freq_list[0]}
           else
             K=$(($T0 - $Thot))
             j=$(($K / Tstep))
                 if [ $j -ge $numfreq ]
                  then
                   j=$numfreq
                 elif [ $j -le 0 ]
                  then
                   j=0
                 fi
     f=${freq_list[$j]}
  fi
    dt=$(echo "$dtsave / (2* $j^2 + 1)" | bc -l) #poll faster when throttling
    echo new j $j
    echo new freq $f
    sleep $dt
done


